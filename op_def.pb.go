// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: op_def.proto

package tensorflow

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Defines an operation. A NodeDef in a GraphDef specifies an Op by
// using the "op" field which should match the name of a OpDef.
type OpDef struct {
	// Op names starting with an underscore are reserved for internal use.
	// Names should be CamelCase and match the regexp "[A-Z][a-zA-Z0-9_]*".
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the input(s).
	InputArg []*OpDef_ArgDef `protobuf:"bytes,2,rep,name=input_arg,json=inputArg" json:"input_arg,omitempty"`
	// Description of the output(s).
	OutputArg []*OpDef_ArgDef  `protobuf:"bytes,3,rep,name=output_arg,json=outputArg" json:"output_arg,omitempty"`
	Attr      []*OpDef_AttrDef `protobuf:"bytes,4,rep,name=attr" json:"attr,omitempty"`
	// Optional deprecation based on GraphDef versions.
	Deprecation *OpDeprecation `protobuf:"bytes,8,opt,name=deprecation" json:"deprecation,omitempty"`
	// One-line human-readable description of what the Op does.
	Summary string `protobuf:"bytes,5,opt,name=summary,proto3" json:"summary,omitempty"`
	// Additional, longer human-readable description of what the Op does.
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// True if the operation is commutative ("op(a,b) == op(b,a)" for all inputs)
	IsCommutative bool `protobuf:"varint,18,opt,name=is_commutative,json=isCommutative,proto3" json:"is_commutative,omitempty"`
	// If is_aggregate is true, then this operation accepts N >= 2
	// inputs and produces 1 output all of the same type.  Should be
	// associative and commutative, and produce output with the same
	// shape as the input.  The optimizer may replace an aggregate op
	// taking input from multiple devices with a tree of aggregate ops
	// that aggregate locally within each device (and possibly within
	// groups of nearby devices) before communicating.
	// TODO(josh11b): Implement that optimization.
	IsAggregate bool `protobuf:"varint,16,opt,name=is_aggregate,json=isAggregate,proto3" json:"is_aggregate,omitempty"`
	// By default Ops may be moved between devices.  Stateful ops should
	// either not be moved, or should only be moved if that state can also
	// be moved (e.g. via some sort of save / restore).
	// Stateful ops are guaranteed to never be optimized away by Common
	// Subexpression Elimination (CSE).
	IsStateful bool `protobuf:"varint,17,opt,name=is_stateful,json=isStateful,proto3" json:"is_stateful,omitempty"`
	// By default, all inputs to an Op must be initialized Tensors.  Ops
	// that may initialize tensors for the first time should set this
	// field to true, to allow the Op to take an uninitialized Tensor as
	// input.
	AllowsUninitializedInput bool `protobuf:"varint,19,opt,name=allows_uninitialized_input,json=allowsUninitializedInput,proto3" json:"allows_uninitialized_input,omitempty"`
}

func (m *OpDef) Reset()         { *m = OpDef{} }
func (m *OpDef) String() string { return proto.CompactTextString(m) }
func (*OpDef) ProtoMessage()    {}
func (*OpDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_op_def_b72fa5111a8a3210, []int{0}
}
func (m *OpDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OpDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpDef.Merge(dst, src)
}
func (m *OpDef) XXX_Size() int {
	return m.Size()
}
func (m *OpDef) XXX_DiscardUnknown() {
	xxx_messageInfo_OpDef.DiscardUnknown(m)
}

var xxx_messageInfo_OpDef proto.InternalMessageInfo

func (m *OpDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OpDef) GetInputArg() []*OpDef_ArgDef {
	if m != nil {
		return m.InputArg
	}
	return nil
}

func (m *OpDef) GetOutputArg() []*OpDef_ArgDef {
	if m != nil {
		return m.OutputArg
	}
	return nil
}

func (m *OpDef) GetAttr() []*OpDef_AttrDef {
	if m != nil {
		return m.Attr
	}
	return nil
}

func (m *OpDef) GetDeprecation() *OpDeprecation {
	if m != nil {
		return m.Deprecation
	}
	return nil
}

func (m *OpDef) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

func (m *OpDef) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *OpDef) GetIsCommutative() bool {
	if m != nil {
		return m.IsCommutative
	}
	return false
}

func (m *OpDef) GetIsAggregate() bool {
	if m != nil {
		return m.IsAggregate
	}
	return false
}

func (m *OpDef) GetIsStateful() bool {
	if m != nil {
		return m.IsStateful
	}
	return false
}

func (m *OpDef) GetAllowsUninitializedInput() bool {
	if m != nil {
		return m.AllowsUninitializedInput
	}
	return false
}

// For describing inputs and outputs.
type OpDef_ArgDef struct {
	// Name for the input/output.  Should match the regexp "[a-z][a-z0-9_]*".
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Human readable description.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Describes the type of one or more tensors that are accepted/produced
	// by this input/output arg.  The only legal combinations are:
	// * For a single tensor: either the "type" field is set or the
	//   "type_attr" field is set to the name of an attr with type "type".
	// * For a sequence of tensors with the same type: the "number_attr"
	//   field will be set to the name of an attr with type "int", and
	//   either the "type" or "type_attr" field will be set as for
	//   single tensors.
	// * For a sequence of tensors, the "type_list_attr" field will be set
	//   to the name of an attr with type "list(type)".
	Type       DataType `protobuf:"varint,3,opt,name=type,proto3,enum=tensorflow.DataType" json:"type,omitempty"`
	TypeAttr   string   `protobuf:"bytes,4,opt,name=type_attr,json=typeAttr,proto3" json:"type_attr,omitempty"`
	NumberAttr string   `protobuf:"bytes,5,opt,name=number_attr,json=numberAttr,proto3" json:"number_attr,omitempty"`
	// If specified, attr must have type "list(type)", and none of
	// type, type_attr, and number_attr may be specified.
	TypeListAttr string `protobuf:"bytes,6,opt,name=type_list_attr,json=typeListAttr,proto3" json:"type_list_attr,omitempty"`
	// For inputs: if true, the inputs are required to be refs.
	//   By default, inputs can be either refs or non-refs.
	// For outputs: if true, outputs are refs, otherwise they are not.
	IsRef bool `protobuf:"varint,16,opt,name=is_ref,json=isRef,proto3" json:"is_ref,omitempty"`
}

func (m *OpDef_ArgDef) Reset()         { *m = OpDef_ArgDef{} }
func (m *OpDef_ArgDef) String() string { return proto.CompactTextString(m) }
func (*OpDef_ArgDef) ProtoMessage()    {}
func (*OpDef_ArgDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_op_def_b72fa5111a8a3210, []int{0, 0}
}
func (m *OpDef_ArgDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpDef_ArgDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpDef_ArgDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OpDef_ArgDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpDef_ArgDef.Merge(dst, src)
}
func (m *OpDef_ArgDef) XXX_Size() int {
	return m.Size()
}
func (m *OpDef_ArgDef) XXX_DiscardUnknown() {
	xxx_messageInfo_OpDef_ArgDef.DiscardUnknown(m)
}

var xxx_messageInfo_OpDef_ArgDef proto.InternalMessageInfo

func (m *OpDef_ArgDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OpDef_ArgDef) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *OpDef_ArgDef) GetType() DataType {
	if m != nil {
		return m.Type
	}
	return DataType_DT_INVALID
}

func (m *OpDef_ArgDef) GetTypeAttr() string {
	if m != nil {
		return m.TypeAttr
	}
	return ""
}

func (m *OpDef_ArgDef) GetNumberAttr() string {
	if m != nil {
		return m.NumberAttr
	}
	return ""
}

func (m *OpDef_ArgDef) GetTypeListAttr() string {
	if m != nil {
		return m.TypeListAttr
	}
	return ""
}

func (m *OpDef_ArgDef) GetIsRef() bool {
	if m != nil {
		return m.IsRef
	}
	return false
}

// Description of the graph-construction-time configuration of this
// Op.  That is to say, this describes the attr fields that will
// be specified in the NodeDef.
type OpDef_AttrDef struct {
	// A descriptive name for the argument.  May be used, e.g. by the
	// Python client, as a keyword argument name, and so should match
	// the regexp "[a-z][a-z0-9_]+".
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// One of the type names from attr_value.proto ("string", "list(string)",
	// "int", etc.).
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// A reasonable default for this attribute if the user does not supply
	// a value.  If not specified, the user must supply a value.
	DefaultValue *AttrValue `protobuf:"bytes,3,opt,name=default_value,json=defaultValue" json:"default_value,omitempty"`
	// Human-readable description.
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// For type == "int", this is a minimum value.  For "list(___)"
	// types, this is the minimum length.
	HasMinimum bool  `protobuf:"varint,5,opt,name=has_minimum,json=hasMinimum,proto3" json:"has_minimum,omitempty"`
	Minimum    int64 `protobuf:"varint,6,opt,name=minimum,proto3" json:"minimum,omitempty"`
	// The set of allowed values.  Has type that is the "list" version
	// of the "type" field above (uses the "list" field of AttrValue).
	// If type == "type" or "list(type)" above, then the "type" field
	// of "allowed_values.list" has the set of allowed DataTypes.
	// If type == "string" or "list(string)", then the "s" field of
	// "allowed_values.list" has the set of allowed strings.
	AllowedValues *AttrValue `protobuf:"bytes,7,opt,name=allowed_values,json=allowedValues" json:"allowed_values,omitempty"`
}

func (m *OpDef_AttrDef) Reset()         { *m = OpDef_AttrDef{} }
func (m *OpDef_AttrDef) String() string { return proto.CompactTextString(m) }
func (*OpDef_AttrDef) ProtoMessage()    {}
func (*OpDef_AttrDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_op_def_b72fa5111a8a3210, []int{0, 1}
}
func (m *OpDef_AttrDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpDef_AttrDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpDef_AttrDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OpDef_AttrDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpDef_AttrDef.Merge(dst, src)
}
func (m *OpDef_AttrDef) XXX_Size() int {
	return m.Size()
}
func (m *OpDef_AttrDef) XXX_DiscardUnknown() {
	xxx_messageInfo_OpDef_AttrDef.DiscardUnknown(m)
}

var xxx_messageInfo_OpDef_AttrDef proto.InternalMessageInfo

func (m *OpDef_AttrDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OpDef_AttrDef) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *OpDef_AttrDef) GetDefaultValue() *AttrValue {
	if m != nil {
		return m.DefaultValue
	}
	return nil
}

func (m *OpDef_AttrDef) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *OpDef_AttrDef) GetHasMinimum() bool {
	if m != nil {
		return m.HasMinimum
	}
	return false
}

func (m *OpDef_AttrDef) GetMinimum() int64 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

func (m *OpDef_AttrDef) GetAllowedValues() *AttrValue {
	if m != nil {
		return m.AllowedValues
	}
	return nil
}

// Information about version-dependent deprecation of an op
type OpDeprecation struct {
	// First GraphDef version at which the op is disallowed.
	Version int32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// Explanation of why it was deprecated and what to use instead.
	Explanation string `protobuf:"bytes,2,opt,name=explanation,proto3" json:"explanation,omitempty"`
}

func (m *OpDeprecation) Reset()         { *m = OpDeprecation{} }
func (m *OpDeprecation) String() string { return proto.CompactTextString(m) }
func (*OpDeprecation) ProtoMessage()    {}
func (*OpDeprecation) Descriptor() ([]byte, []int) {
	return fileDescriptor_op_def_b72fa5111a8a3210, []int{1}
}
func (m *OpDeprecation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpDeprecation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpDeprecation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OpDeprecation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpDeprecation.Merge(dst, src)
}
func (m *OpDeprecation) XXX_Size() int {
	return m.Size()
}
func (m *OpDeprecation) XXX_DiscardUnknown() {
	xxx_messageInfo_OpDeprecation.DiscardUnknown(m)
}

var xxx_messageInfo_OpDeprecation proto.InternalMessageInfo

func (m *OpDeprecation) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *OpDeprecation) GetExplanation() string {
	if m != nil {
		return m.Explanation
	}
	return ""
}

// A collection of OpDefs
type OpList struct {
	Op []*OpDef `protobuf:"bytes,1,rep,name=op" json:"op,omitempty"`
}

func (m *OpList) Reset()         { *m = OpList{} }
func (m *OpList) String() string { return proto.CompactTextString(m) }
func (*OpList) ProtoMessage()    {}
func (*OpList) Descriptor() ([]byte, []int) {
	return fileDescriptor_op_def_b72fa5111a8a3210, []int{2}
}
func (m *OpList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OpList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpList.Merge(dst, src)
}
func (m *OpList) XXX_Size() int {
	return m.Size()
}
func (m *OpList) XXX_DiscardUnknown() {
	xxx_messageInfo_OpList.DiscardUnknown(m)
}

var xxx_messageInfo_OpList proto.InternalMessageInfo

func (m *OpList) GetOp() []*OpDef {
	if m != nil {
		return m.Op
	}
	return nil
}

func init() {
	proto.RegisterType((*OpDef)(nil), "tensorflow.OpDef")
	proto.RegisterType((*OpDef_ArgDef)(nil), "tensorflow.OpDef.ArgDef")
	proto.RegisterType((*OpDef_AttrDef)(nil), "tensorflow.OpDef.AttrDef")
	proto.RegisterType((*OpDeprecation)(nil), "tensorflow.OpDeprecation")
	proto.RegisterType((*OpList)(nil), "tensorflow.OpList")
}
func (m *OpDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.InputArg) > 0 {
		for _, msg := range m.InputArg {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOpDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OutputArg) > 0 {
		for _, msg := range m.OutputArg {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintOpDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Attr) > 0 {
		for _, msg := range m.Attr {
			dAtA[i] = 0x22
			i++
			i = encodeVarintOpDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Summary) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Summary)))
		i += copy(dAtA[i:], m.Summary)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Deprecation != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(m.Deprecation.Size()))
		n1, err := m.Deprecation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.IsAggregate {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.IsAggregate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsStateful {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.IsStateful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsCommutative {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.IsCommutative {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AllowsUninitializedInput {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.AllowsUninitializedInput {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *OpDef_ArgDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpDef_ArgDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(m.Type))
	}
	if len(m.TypeAttr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.TypeAttr)))
		i += copy(dAtA[i:], m.TypeAttr)
	}
	if len(m.NumberAttr) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.NumberAttr)))
		i += copy(dAtA[i:], m.NumberAttr)
	}
	if len(m.TypeListAttr) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.TypeListAttr)))
		i += copy(dAtA[i:], m.TypeListAttr)
	}
	if m.IsRef {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.IsRef {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *OpDef_AttrDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpDef_AttrDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.DefaultValue != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(m.DefaultValue.Size()))
		n2, err := m.DefaultValue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.HasMinimum {
		dAtA[i] = 0x28
		i++
		if m.HasMinimum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Minimum != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(m.Minimum))
	}
	if m.AllowedValues != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(m.AllowedValues.Size()))
		n3, err := m.AllowedValues.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *OpDeprecation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpDeprecation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(m.Version))
	}
	if len(m.Explanation) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Explanation)))
		i += copy(dAtA[i:], m.Explanation)
	}
	return i, nil
}

func (m *OpList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Op) > 0 {
		for _, msg := range m.Op {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintOpDef(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *OpDef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	if len(m.InputArg) > 0 {
		for _, e := range m.InputArg {
			l = e.Size()
			n += 1 + l + sovOpDef(uint64(l))
		}
	}
	if len(m.OutputArg) > 0 {
		for _, e := range m.OutputArg {
			l = e.Size()
			n += 1 + l + sovOpDef(uint64(l))
		}
	}
	if len(m.Attr) > 0 {
		for _, e := range m.Attr {
			l = e.Size()
			n += 1 + l + sovOpDef(uint64(l))
		}
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	if m.Deprecation != nil {
		l = m.Deprecation.Size()
		n += 1 + l + sovOpDef(uint64(l))
	}
	if m.IsAggregate {
		n += 3
	}
	if m.IsStateful {
		n += 3
	}
	if m.IsCommutative {
		n += 3
	}
	if m.AllowsUninitializedInput {
		n += 3
	}
	return n
}

func (m *OpDef_ArgDef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovOpDef(uint64(m.Type))
	}
	l = len(m.TypeAttr)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	l = len(m.NumberAttr)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	l = len(m.TypeListAttr)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	if m.IsRef {
		n += 3
	}
	return n
}

func (m *OpDef_AttrDef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	if m.DefaultValue != nil {
		l = m.DefaultValue.Size()
		n += 1 + l + sovOpDef(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	if m.HasMinimum {
		n += 2
	}
	if m.Minimum != 0 {
		n += 1 + sovOpDef(uint64(m.Minimum))
	}
	if m.AllowedValues != nil {
		l = m.AllowedValues.Size()
		n += 1 + l + sovOpDef(uint64(l))
	}
	return n
}

func (m *OpDeprecation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovOpDef(uint64(m.Version))
	}
	l = len(m.Explanation)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	return n
}

func (m *OpList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Op) > 0 {
		for _, e := range m.Op {
			l = e.Size()
			n += 1 + l + sovOpDef(uint64(l))
		}
	}
	return n
}

func sovOpDef(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOpDef(x uint64) (n int) {
	return sovOpDef(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OpDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputArg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputArg = append(m.InputArg, &OpDef_ArgDef{})
			if err := m.InputArg[len(m.InputArg)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputArg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputArg = append(m.OutputArg, &OpDef_ArgDef{})
			if err := m.OutputArg[len(m.OutputArg)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr = append(m.Attr, &OpDef_AttrDef{})
			if err := m.Attr[len(m.Attr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deprecation == nil {
				m.Deprecation = &OpDeprecation{}
			}
			if err := m.Deprecation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAggregate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAggregate = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStateful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStateful = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCommutative", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCommutative = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowsUninitializedInput", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowsUninitializedInput = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOpDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpDef_ArgDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (DataType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeAttr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeAttr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberAttr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NumberAttr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeListAttr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeListAttr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRef", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRef = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOpDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpDef_AttrDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttrDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttrDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValue == nil {
				m.DefaultValue = &AttrValue{}
			}
			if err := m.DefaultValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMinimum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMinimum = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minimum", wireType)
			}
			m.Minimum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minimum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllowedValues == nil {
				m.AllowedValues = &AttrValue{}
			}
			if err := m.AllowedValues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpDeprecation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpDeprecation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpDeprecation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Explanation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Explanation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = append(m.Op, &OpDef{})
			if err := m.Op[len(m.Op)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOpDef(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOpDef
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOpDef
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOpDef
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOpDef(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOpDef = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOpDef   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("op_def.proto", fileDescriptor_op_def_b72fa5111a8a3210) }

var fileDescriptor_op_def_b72fa5111a8a3210 = []byte{
	// 640 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0x4f, 0x6f, 0x13, 0x3f,
	0x10, 0xad, 0xf3, 0x3f, 0xb3, 0x49, 0xd4, 0xfa, 0xf7, 0xab, 0x64, 0x82, 0x94, 0xa6, 0x15, 0x48,
	0x91, 0x10, 0x39, 0x14, 0x21, 0x24, 0xe8, 0xa5, 0x25, 0x17, 0x04, 0xa8, 0xd5, 0xf2, 0xe7, 0xba,
	0x72, 0x1b, 0xef, 0xd6, 0x62, 0x77, 0x6d, 0xd9, 0xde, 0x96, 0xf2, 0x09, 0x38, 0xf2, 0xb1, 0xb8,
	0x20, 0xf5, 0xc8, 0x11, 0x35, 0x5f, 0x82, 0x23, 0xb2, 0xbd, 0xa1, 0x4b, 0x1b, 0xc1, 0x29, 0x99,
	0x37, 0xef, 0x79, 0x67, 0xde, 0x8c, 0x0d, 0x3d, 0x21, 0xa3, 0x39, 0x8b, 0xa7, 0x52, 0x09, 0x23,
	0x30, 0x18, 0x96, 0x6b, 0xa1, 0xe2, 0x54, 0x9c, 0x0f, 0xd7, 0xa9, 0x31, 0x2a, 0x3a, 0xa3, 0x69,
	0xc1, 0x7c, 0x76, 0x18, 0x98, 0x0b, 0xc9, 0xb4, 0x0f, 0x76, 0xbe, 0xb5, 0xa1, 0x79, 0x28, 0x67,
	0x2c, 0xc6, 0x18, 0x1a, 0x39, 0xcd, 0x18, 0x41, 0x63, 0x34, 0xe9, 0x86, 0xee, 0x3f, 0x7e, 0x0c,
	0x5d, 0x9e, 0xcb, 0xc2, 0x44, 0x54, 0x25, 0xa4, 0x36, 0xae, 0x4f, 0x82, 0x5d, 0x32, 0xbd, 0x3e,
	0x7c, 0xea, 0x94, 0xd3, 0x7d, 0x95, 0xcc, 0x58, 0x1c, 0x76, 0x1c, 0x75, 0x5f, 0x25, 0xf8, 0x09,
	0x80, 0x28, 0xcc, 0x52, 0x57, 0xff, 0x87, 0xae, 0xeb, 0xb9, 0x56, 0xf8, 0x10, 0x1a, 0xb6, 0x5c,
	0xd2, 0x70, 0x92, 0x3b, 0x2b, 0x24, 0xc6, 0x28, 0xab, 0x71, 0x34, 0x4c, 0xa0, 0xad, 0x8b, 0x2c,
	0xa3, 0xea, 0x82, 0x34, 0x5d, 0xd5, 0xcb, 0x10, 0x8f, 0x21, 0x98, 0x33, 0x7d, 0xa2, 0xb8, 0x34,
	0x5c, 0xe4, 0xa4, 0xe5, 0xb2, 0x55, 0x08, 0x3f, 0xb3, 0x0c, 0xa9, 0xd8, 0x09, 0x75, 0x8c, 0xce,
	0x18, 0xad, 0xfa, 0xe2, 0x6f, 0x42, 0x58, 0x65, 0xe3, 0x6d, 0xe8, 0x71, 0x1d, 0xd1, 0x24, 0x51,
	0x2c, 0xa1, 0x86, 0x91, 0xf5, 0x31, 0x9a, 0x74, 0xc2, 0x80, 0xeb, 0xfd, 0x25, 0x84, 0xb7, 0x20,
	0xe0, 0x3a, 0xd2, 0x86, 0x1a, 0x16, 0x17, 0x29, 0xd9, 0x70, 0x0c, 0xe0, 0xfa, 0x4d, 0x89, 0xe0,
	0xfb, 0x30, 0xe0, 0x3a, 0x3a, 0x11, 0x59, 0x56, 0x18, 0x6a, 0xf8, 0x19, 0x23, 0xd8, 0x71, 0xfa,
	0x5c, 0x3f, 0xbf, 0x06, 0xf1, 0x1e, 0x0c, 0x69, 0x9a, 0x8a, 0x73, 0x1d, 0x15, 0x39, 0xcf, 0xb9,
	0xe1, 0x34, 0xe5, 0x9f, 0xd8, 0x3c, 0x72, 0x66, 0x93, 0xff, 0x9c, 0x84, 0x78, 0xc6, 0xbb, 0x2a,
	0xe1, 0x85, 0xcd, 0x0f, 0x17, 0x08, 0x5a, 0xde, 0xe6, 0x95, 0xf3, 0xbd, 0x61, 0x53, 0xed, 0xb6,
	0x4d, 0x13, 0x68, 0xd8, 0x75, 0x21, 0xf5, 0x31, 0x9a, 0x0c, 0x76, 0xff, 0xaf, 0xfa, 0x33, 0xa3,
	0x86, 0xbe, 0xbd, 0x90, 0x2c, 0x74, 0x0c, 0x7c, 0x17, 0xba, 0xf6, 0x37, 0x2a, 0x07, 0x68, 0x4f,
	0xea, 0x58, 0xc0, 0x8e, 0xcc, 0xba, 0x91, 0x17, 0xd9, 0x31, 0x53, 0x3e, 0xed, 0xa7, 0x05, 0x1e,
	0x72, 0x84, 0x7b, 0x30, 0x70, 0xea, 0x94, 0x6b, 0xe3, 0x39, 0x7e, 0x66, 0x3d, 0x8b, 0xbe, 0xe2,
	0xda, 0x38, 0xd6, 0x26, 0xb4, 0xb8, 0x8e, 0x14, 0x8b, 0x4b, 0xc7, 0x9b, 0x5c, 0x87, 0x2c, 0x1e,
	0x7e, 0xae, 0x41, 0xbb, 0xdc, 0x8c, 0x95, 0x6d, 0xe2, 0xb2, 0x09, 0xdf, 0x9f, 0x2f, 0xf7, 0x29,
	0xf4, 0xe7, 0x2c, 0xa6, 0x45, 0x6a, 0xfc, 0xe5, 0x70, 0x1d, 0x06, 0xbb, 0x9b, 0xd5, 0x0e, 0xed,
	0x99, 0xef, 0x6d, 0x32, 0xec, 0x95, 0x5c, 0x17, 0xdd, 0xb4, 0xad, 0x71, 0xdb, 0xb6, 0x2d, 0x08,
	0x4e, 0xa9, 0x8e, 0x32, 0x9e, 0xf3, 0xac, 0xc8, 0x5c, 0xbf, 0x9d, 0x10, 0x4e, 0xa9, 0x7e, 0xed,
	0x11, 0xbb, 0xba, 0xcb, 0xa4, 0x6d, 0xb4, 0x1e, 0x2e, 0x43, 0xbc, 0x07, 0x03, 0x37, 0x4e, 0x36,
	0xf7, 0x85, 0x69, 0xd2, 0xfe, 0x5b, 0x65, 0xfd, 0x92, 0xec, 0x22, 0xbd, 0xf3, 0x12, 0xfa, 0x7f,
	0xec, 0xad, 0xfd, 0xd0, 0x19, 0x53, 0xda, 0xd6, 0x69, 0x2d, 0x69, 0x86, 0xcb, 0xd0, 0x76, 0xc1,
	0x3e, 0xca, 0x94, 0xe6, 0xb4, 0x3a, 0xfc, 0x0a, 0xb4, 0xf3, 0x00, 0x5a, 0x87, 0xd2, 0x9a, 0x8f,
	0xb7, 0xa1, 0x26, 0x24, 0x41, 0xee, 0x5a, 0x6e, 0xdc, 0xba, 0x96, 0x61, 0x4d, 0xc8, 0x83, 0xd9,
	0xd7, 0xab, 0x11, 0xba, 0xbc, 0x1a, 0xa1, 0x1f, 0x57, 0x23, 0xf4, 0x65, 0x31, 0x5a, 0xbb, 0x5c,
	0x8c, 0xd6, 0xbe, 0x2f, 0x46, 0x6b, 0x40, 0x84, 0x4a, 0xaa, 0x9a, 0x58, 0xd1, 0x8c, 0x9d, 0x0b,
	0xf5, 0xe1, 0x20, 0x70, 0xf2, 0x23, 0xfb, 0x12, 0xe9, 0x23, 0xf4, 0x13, 0xa1, 0xe3, 0x96, 0x7b,
	0x96, 0x1e, 0xfd, 0x0a, 0x00, 0x00, 0xff, 0xff, 0xbe, 0x90, 0x15, 0x3b, 0xd1, 0x04, 0x00, 0x00,
}
